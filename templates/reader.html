<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ book.metadata.title }}</title>
    <style>
        /* Layout */
        body { margin: 0; padding: 0; display: flex; height: 100vh; overflow: hidden; font-family: "Georgia", serif; }
        body.theme-light { background: #f5f5f7; color: #111827; }
        body.theme-dark { background: #020617; color: #e5e7eb; }

        /* Sidebar */
        #sidebar { width: 300px; background: rgba(248,249,250,0.95); border-right: 1px solid #e5e7eb; overflow-y: auto; padding: 20px; flex-shrink: 0; backdrop-filter: blur(12px); }
        .nav-header-row { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #dee2e6; }
        .nav-header { font-family: -apple-system, sans-serif; font-weight: bold; color: #111827; font-size: 1rem; }
        .nav-home { display: block; margin-bottom: 16px; color: #2563eb; text-decoration: none; font-family: -apple-system, sans-serif; font-size: 0.9em; }
        .nav-home:hover { color: #1d4ed8; }
        .theme-toggle-btn { border-radius: 999px; border: 1px solid rgba(148,163,184,0.9); background: rgba(255,255,255,0.85); color: #0f172a; font-size: 0.75rem; padding: 4px 10px; cursor: pointer; transition: background 0.2s, color 0.2s, border-color 0.2s, transform 0.1s; white-space: nowrap; }
        .theme-toggle-btn:hover { background: #0f172a; color: #f9fafb; border-color: #0f172a; transform: translateY(-1px); }
        body.theme-dark #sidebar { background: rgba(15,23,42,0.95); border-right-color: #1f2937; }
        body.theme-dark .nav-header { color: #e5e7eb; }
        body.theme-dark .nav-home { color: #60a5fa; }
        body.theme-dark .nav-home:hover { color: #bfdbfe; }
        body.theme-dark .theme-toggle-btn { background: rgba(15,23,42,0.95); color: #e5e7eb; border-color: #4b5563; }
        body.theme-dark .theme-toggle-btn:hover { background: #e5e7eb; color: #020617; border-color: #e5e7eb; }

        /* TOC Tree */
        ul.toc-list { list-style: none; padding-left: 0; margin: 0; }
        ul.toc-list ul { padding-left: 20px; } /* Indent children */
        li.toc-item { margin-bottom: 8px; }
        a.toc-link { text-decoration: none; color: #4b5563; font-size: 0.95em; display: block; padding: 4px 4px; line-height: 1.4; border-radius: 4px; transition: background 0.15s, color 0.15s; }
        a.toc-link:hover { color: #111827; background: rgba(148,163,184,0.16); text-decoration: none; }
        a.toc-link.active { color: #1d4ed8; font-weight: bold; background: rgba(37,99,235,0.12); }
        body.theme-dark a.toc-link { color: #9ca3af; }
        body.theme-dark a.toc-link:hover { color: #f9fafb; background: rgba(55,65,81,0.8); }
        body.theme-dark a.toc-link.active { color: #bfdbfe; background: rgba(37,99,235,0.35); }

        /* Main Content */
        #main { flex-grow: 1; overflow-y: auto; position: relative; scroll-behavior: smooth; background: radial-gradient(circle at top left, rgba(59,130,246,0.10), transparent 55%), radial-gradient(circle at bottom right, rgba(236,72,153,0.08), transparent 55%); }
        .content-container { max-width: 760px; margin: 32px auto; padding: 48px 48px 64px; line-height: 1.9; font-size: 1.06em; color: #1f2933; background: rgba(255,255,255,0.96); border-radius: 18px; box-shadow: 0 18px 45px rgba(15,23,42,0.15); }
        body.theme-dark #main { background: radial-gradient(circle at top left, rgba(59,130,246,0.22), transparent 55%), radial-gradient(circle at bottom right, rgba(236,72,153,0.20), transparent 55%); }
        body.theme-dark .content-container { background: rgba(15,23,42,0.96); color: #e5e7eb; box-shadow: 0 20px 50px rgba(0,0,0,0.65); }

        /* Content Styling (Basic normalization for the book HTML) */
        .book-content img { max-width: 100%; height: auto; display: block; margin: 24px auto; border-radius: 8px; box-shadow: 0 8px 20px rgba(15,23,42,0.25); }
        .book-content h1, .book-content h2, .book-content h3 { font-family: -apple-system, sans-serif; margin-top: 1.7em; margin-bottom: 0.6em; color: #111827; letter-spacing: 0.01em; }
        .book-content p { margin-bottom: 1.35em; text-align: justify; text-justify: inter-word; }
        .book-content pre { margin: 24px 0; padding: 14px 16px; border-radius: 10px; max-width: 100%; box-sizing: border-box; overflow-x: auto; white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.9em; line-height: 1.35; border: 1px solid rgba(15,23,42,0.55); }
        .book-content :not(pre) > code { padding: 0.1em 0.3em; border-radius: 4px; background: rgba(15,23,42,0.06); font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.88em; }
        .book-content pre code { background: transparent; padding: 0; border: none; white-space: pre; }
        .book-content pre.code-block { position: relative; padding-top: 32px; }
        .book-content pre .code-toolbar { position: absolute; top: 6px; right: 10px; display: flex; gap: 6px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; font-size: 0.72rem; }
        .book-content pre .code-wrap-toggle { border-radius: 999px; border: 1px solid rgba(148,163,184,0.8); background: rgba(255,255,255,0.85); color: #111827; padding: 3px 10px; cursor: pointer; transition: background 0.15s, color 0.15s, border-color 0.15s, transform 0.1s; }
        .book-content pre .code-wrap-toggle:hover { background: #0f172a; color: #f9fafb; border-color: #0f172a; transform: translateY(-1px); }
        .book-content pre .code-line { display: flex; align-items: flex-start; }
        .book-content pre .code-lineno { width: 3em; flex-shrink: 0; text-align: right; padding-right: 0.9em; opacity: 0.6; user-select: none; color: inherit; }
        .book-content pre .code-text { flex: 1; white-space: pre; }
        .book-content pre.code-wrap-on .code-text { white-space: pre-wrap; word-wrap: break-word; }
        body.theme-dark .book-content h1, body.theme-dark .book-content h2, body.theme-dark .book-content h3 { color: #e5e7eb; }
        body.theme-dark .book-content img { box-shadow: 0 10px 26px rgba(0,0,0,0.7); }
        body.theme-light .book-content pre { background: #f9fafb; color: #111827; border-color: #e5e7eb; box-shadow: 0 10px 20px rgba(15,23,42,0.25); }
        body.theme-dark .book-content pre { background: #020617; color: #e5e7eb; border-color: #4b5563; box-shadow: 0 18px 40px rgba(0,0,0,0.85); }
        body.theme-dark .book-content :not(pre) > code { background: rgba(15,23,42,0.85); color: #e5e7eb; }

        /* Navigation Footer */
        .chapter-nav { display: flex; justify-content: space-between; margin-top: 60px; padding-top: 20px; border-top: 1px solid #e5e7eb; font-family: -apple-system, sans-serif; align-items: center; }
        .nav-btn { text-decoration: none; color: #2563eb; font-weight: 600; padding: 10px 22px; border: 1px solid #2563eb; border-radius: 999px; transition: all 0.2s; background: #eff6ff; }
        .nav-btn:hover { background: #2563eb; color: white; box-shadow: 0 10px 20px rgba(37,99,235,0.4); transform: translateY(-1px); }
        .nav-btn.disabled { opacity: 0.4; pointer-events: none; border-color: #cbd5f5; color: #9ca3af; background: #f3f4f6; box-shadow: none; }
        body.theme-dark .chapter-nav { border-top-color: #374151; }
        body.theme-dark .nav-btn { background: rgba(15,23,42,0.9); border-color: #60a5fa; color: #e5e7eb; }
        body.theme-dark .nav-btn:hover { background: #60a5fa; color: #020617; box-shadow: 0 10px 24px rgba(37,99,235,0.7); }
        body.theme-dark .nav-btn.disabled { background: #111827; border-color: #4b5563; color: #6b7280; }

    </style>
</head>
<body class="theme-light">

    <!-- SIDEBAR -->
    <div id="sidebar">
        <a href="/" class="nav-home">← Back to Library</a>
        <div class="nav-header-row">
            <div class="nav-header">{{ book.metadata.title }}</div>
            <button id="theme-toggle" type="button" class="theme-toggle-btn" onclick="toggleTheme()">深色模式</button>
        </div>

        <!-- Recursive Macro for TOC -->
        {% macro render_toc(items) %}
            <ul class="toc-list">
            {% for item in items %}
                <li class="toc-item">
                    <!--
                        Matching Logic:
                        Prefer using anchor_map (file or file#anchor -> spine index)
                        to decide which TOC entry is active for the current chapter_index.
                        If anchor_map is empty (older data), fall back to filename match.
                    -->
                    {% set amap = book.anchor_map %}
                    {% set has_direct_index = (item.chapter_index is not none) %}
                    {% set idx_from_href = amap.get(item.href) if amap else none %}
                    {% set idx_from_file = amap.get(item.file_href) if amap else none %}
                    {% set is_active = (has_direct_index and item.chapter_index == chapter_index)
                        or (not has_direct_index and idx_from_href is not none and idx_from_href == chapter_index)
                        or (not has_direct_index and idx_from_href is none and idx_from_file is not none and idx_from_file == chapter_index)
                        or (not has_direct_index and not amap and current_chapter.href == item.file_href) %}

                    <!--
                       We need to find which linear chapter index (0, 1, 2) corresponds
                       to this TOC entry file.
                       Since that's hard to calculate in Jinja, we just link to the
                       file anchor. BUT, to make our linear navigation work, we
                       rely on the fact that the user is currently reading 'chapter_index'.

                       Ideally, clicking a TOC link should find the 'index' of that file.
                       For simplicity in this version: We link to the 'href' (filename)
                       and let JavaScript or Backend handle it?

                       Actually, let's just link to the file. The browser interprets #anchors.
                       However, our router uses /read/book/INDEX.

                       SIMPLE FIX: We won't link the TOC to the route index in this simple version
                       unless we build a map. We will visually show structure,
                       but rely on "Previous/Next" for linear reading.

                       BETTER FIX: Use JavaScript to match filenames.
                    -->
                    <a href="#" onclick="findAndGo('{{ item.href }}', {{ item.chapter_index if item.chapter_index is not none else 'null' }})"
                       class="toc-link {% if is_active %}active{% endif %}">
                        {{ item.title }}
                    </a>

                    {% if item.children %}
                        {{ render_toc(item.children) }}
                    {% endif %}
                </li>
            {% endfor %}
            </ul>
        {% endmacro %}

        {{ render_toc(book.toc) }}
    </div>

    <!-- MAIN CONTENT -->
    <div id="main">
        <div class="content-container">
            <div class="book-content">
                {{ current_chapter.content | safe }}
            </div>

            <div class="chapter-nav">
                {% if prev_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ prev_idx }}" class="nav-btn">← Previous</a>
                {% else %}
                    <span class="nav-btn disabled">← Previous</span>
                {% endif %}

                <span style="color: #999; padding: 10px;">
                    Section {{ chapter_index + 1 }} of {{ book.spine|length }}
                </span>

                {% if next_idx is not none %}
                    <a href="/read/{{ book_id }}/{{ next_idx }}" class="nav-btn">Next →</a>
                {% else %}
                    <span class="nav-btn disabled">Next →</span>
                {% endif %}
            </div>
        </div>
    </div>

    <script>
        // Preserve sidebar (TOC) scroll position per book
        const sidebar = document.getElementById("sidebar");
        const SCROLL_KEY = "reader3_sidebar_scroll_{{ book_id }}";

        (function restoreSidebarScroll() {
            if (!sidebar) return;
            try {
                const saved = localStorage.getItem(SCROLL_KEY);
                if (saved !== null) {
                    const y = parseInt(saved, 10);
                    if (!Number.isNaN(y)) {
                        sidebar.scrollTop = y;
                    }
                }
            } catch (e) {
                console.debug("Failed to restore sidebar scroll:", e);
            }
        })();

        window.addEventListener("beforeunload", () => {
            if (!sidebar) return;
            try {
                localStorage.setItem(SCROLL_KEY, String(sidebar.scrollTop));
            } catch (e) {
                console.debug("Failed to persist sidebar scroll:", e);
            }
        });

        const THEME_KEY = "reader3_theme";

        function applyTheme(theme) {
            const bodyEl = document.body;
            if (!bodyEl) return;
            const next = theme === "dark" ? "theme-dark" : "theme-light";
            bodyEl.classList.remove("theme-light", "theme-dark");
            bodyEl.classList.add(next);
            const btn = document.getElementById("theme-toggle");
            if (btn) {
                btn.textContent = next === "theme-dark" ? "浅色模式" : "深色模式";
            }
        }

        function initTheme() {
            let theme = "light";
            try {
                const stored = localStorage.getItem(THEME_KEY);
                if (stored === "light" || stored === "dark") {
                    theme = stored;
                } else if (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches) {
                    theme = "dark";
                }
            } catch (e) {
            }
            applyTheme(theme);
        }

        function toggleTheme() {
            let next = "light";
            if (document.body && document.body.classList.contains("theme-light")) {
                next = "dark";
            }
            applyTheme(next);
            try {
                localStorage.setItem(THEME_KEY, next);
            } catch (e) {
            }
        }

        function enhanceCodeBlocks() {
            const blocks = document.querySelectorAll(".book-content pre");
            const escapeHtml = (str) => {
                return str
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            };

            blocks.forEach((pre) => {
                if (pre.dataset.enhanced === "1") {
                    return;
                }
                pre.dataset.enhanced = "1";
                pre.classList.add("code-block", "code-wrap-off");

                let code = pre.querySelector("code");
                let rawText = code ? code.textContent : pre.textContent || "";
                if (rawText.endsWith("\n")) {
                    rawText = rawText.slice(0, -1);
                }
                const lines = rawText.split("\n");

                const numbered = lines.map((line, idx) => {
                    const safe = escapeHtml(line === "" ? " " : line);
                    const ln = idx + 1;
                    return "<span class=\"code-line\">" +
                        "<span class=\"code-lineno\">" + ln + "</span>" +
                        "<span class=\"code-text\">" + safe + "</span>" +
                        "</span>";
                }).join("\n");

                if (!code) {
                    pre.innerHTML = "<code>" + numbered + "</code>";
                    code = pre.querySelector("code");
                } else {
                    code.innerHTML = numbered;
                }

                const toolbar = document.createElement("div");
                toolbar.className = "code-toolbar";
                const wrapBtn = document.createElement("button");
                wrapBtn.type = "button";
                wrapBtn.className = "code-wrap-toggle";
                wrapBtn.textContent = "开启换行";
                wrapBtn.addEventListener("click", () => {
                    const wrapOn = !pre.classList.contains("code-wrap-on");
                    pre.classList.toggle("code-wrap-on", wrapOn);
                    pre.classList.toggle("code-wrap-off", !wrapOn);
                    wrapBtn.textContent = wrapOn ? "关闭换行" : "开启换行";
                });
                toolbar.appendChild(wrapBtn);
                pre.insertBefore(toolbar, pre.firstChild);
            });
        }

        document.addEventListener("DOMContentLoaded", () => {
            initTheme();
            enhanceCodeBlocks();
        });

        // Helper to map TOC filenames to Spine Indices
        // Pass the spine data from python to JS
        const spineMap = {
            {% for ch in book.spine %}
            "{{ ch.href }}": {{ ch.order }},
            {% endfor %}
        };

        // Secondary map using just the basename, to be tolerant of path differences
        const spineBasenameMap = {};
        for (const [path, idx] of Object.entries(spineMap)) {
            const parts = path.split("/");
            const name = parts[parts.length - 1];
            if (!(name in spineBasenameMap)) {
                spineBasenameMap[name] = idx;
            }
        }

        // Anchor map produced by the backend during EPUB processing.
        // Keys look like "file.xhtml#anchor" or just "file.xhtml" and
        // values are the linear spine index.
        const anchorMap = {
            {% for key, val in book.anchor_map.items() %}
            "{{ key }}": {{ val }},
            {% endfor %}
        };

        function findAndGo(filename, directIndex) {
            // The TOC usually has specific filenames e.g. "text/part001.html"
            // Sometimes it has anchors "text/part001.html#header"
            const cleanFile = filename.split('#')[0];
            const hasAnchor = filename.indexOf('#') !== -1;
            const anchor = hasAnchor ? filename.split('#')[1] : null;

            // 1) If backend has already resolved the exact chapter index for this
            //    TOC entry, trust that first. This decouples navigation from how
            //    we physically split chapters.
            let idx = (directIndex !== null && directIndex !== undefined) ? directIndex : undefined;

            // 2) If no direct index, fall back to anchorMap/spineMap-based lookup
            if (idx === undefined) {
                if (anchor && anchorMap[cleanFile + '#' + anchor] !== undefined) {
                    idx = anchorMap[cleanFile + '#' + anchor];
                } else if (anchorMap[cleanFile] !== undefined) {
                    idx = anchorMap[cleanFile];
                } else {
                    idx = spineMap[cleanFile];
                    if (idx === undefined) {
                        const parts = cleanFile.split("/");
                        const basename = parts[parts.length - 1];
                        idx = spineBasenameMap[basename];
                    }
                }
            }

            if (idx !== undefined) {
                let url = "/read/{{ book_id }}/" + idx;
                if (anchor) {
                    url += "#" + encodeURIComponent(anchor);
                }
                window.location.href = url;
            } else {
                console.log("Could not find index for", filename, "directIndex=", directIndex);
            }
        }

        // After a chapter loads, if there's a hash like #section-id,
        // scroll the inner main container to that element so large
        // documents can jump to deep headings even though #main is scrollable.
        window.addEventListener("load", () => {
            const main = document.getElementById("main");
            if (!main) return;

            const hash = window.location.hash;
            if (!hash || hash.length <= 1) return;

            const id = decodeURIComponent(hash.substring(1));
            const target = document.getElementById(id);
            if (!target) return;

            const rect = target.getBoundingClientRect();
            const mainRect = main.getBoundingClientRect();
            const offset = rect.top - mainRect.top + main.scrollTop - 40; // small padding
            main.scrollTop = offset;
        });
    </script>
</body>
</html>
